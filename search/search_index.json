{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"CONTRIBUTING.html","title":"CONTRIBUTING","text":"<p>We welcome contributions!</p>"},{"location":"CONTRIBUTING.html#guidelines","title":"Guidelines","text":"<ul> <li>Small and focused PRs. Please don't include changes that don't address the subject of your PR.</li> <li>Follow the style of importing functions directly e.g. <code>from os.path import abspath</code>.</li> <li>Check out the core values of Piku.</li> <li>PEP8.</li> </ul>"},{"location":"DESIGN.html","title":"Design Notes","text":"<p>The idea behind <code>piku</code> is that it provides the simplest possible way to deploy web apps or services. Simplicity comes at the expense of features, of course, and this document tries to capture the trade-offs.</p>"},{"location":"DESIGN.html#why-uwsgi","title":"Why uWSGI","text":"<p>Using uWSGI in emperor mode gives us the following features for free:</p> <ul> <li>Painless Python WSGI and <code>virtualenv</code> integration</li> <li>Process monitoring, restarting, basic resource limiting, etc.</li> <li>Basic security scaffolding, beginning with the ability to define <code>uid</code>/<code>gid</code> on a per-app basis (if necessary)</li> </ul>"},{"location":"DESIGN.html#application-packaging","title":"Application packaging","text":"<p>An app is simply a <code>git</code> repository with some additional files on the top level, the most important of which is the <code>Procfile</code>.</p>"},{"location":"DESIGN.html#procfile-format","title":"<code>Procfile</code> format","text":"<p><code>piku</code> recognizes six kinds of process declarations in the <code>Procfile</code>:</p> <ul> <li><code>wsgi</code> workers, in the format <code>dotted.module:entry_point</code> (Python-only)</li> <li><code>web</code> workers, which can be anything that honors the <code>PORT</code> environment variable</li> <li><code>static</code> workers, which simply mount the first argument as the root static path</li> <li><code>preflight</code> which is a special \"worker\" that is run once before the app is deployed and installing deps (can be useful for cleanups).</li> <li><code>release</code> which is a special worker that is run once when the app is deployed, after installing deps (can be useful for build steps).</li> <li><code>cron</code> workers, which require a simplified <code>cron</code> expression preceding the command to be run (e.g. <code>cron: */5 * * * * python batch.py</code> to run a batch every 5 minutes)</li> <li><code>worker</code> processes, which are standalone workers and can have arbitrary names</li> </ul> <p>So a Python application could have a <code>Procfile</code> like such:</p> <pre><code># A module to be loaded by uwsgi to serve HTTP requests\nwsgi: module.submodule:app\n# A background worker\nworker: python long_running_script.py\n# Another worker with a different name\nfetcher: python fetcher.py\n# Simple cron expression: minute [0-59], hour [0-23], day [0-31], month [1-12], weekday [1-7] (starting Monday, no ranges allowed on any field)\ncron: 0 0 * * * python midnight_cleanup.py\nrelease: python initial_cleanup.py\n</code></pre> <p>...whereas a generic app would be:</p> <pre><code>web: embedded_server --port $PORT\nworker: background_worker\n</code></pre> <p>Any worker will be automatically respawned upon failure (uWSGI will automatically shun/throttle crashy workers).</p>"},{"location":"DESIGN.html#env-settings","title":"<code>ENV</code> settings","text":"<p>Since <code>piku</code> is targeted at 12 Factor apps, it allows you to set environment variables in a number of ways, the simplest of which is by adding an <code>ENV</code> file to your repository:</p> <pre><code>SETTING1=foo\n# piku supports comments and variable expansion\nSETTING2=${SETTING1}/bar\n# if this isn't defined, piku will assign a random TCP port\nPORT=9080\n</code></pre> <p>See ENV.md for a full list of Piku variables which can also be set.</p> <p>Environment variables can be changed after deployment using <code>config:set</code>.</p>"},{"location":"DESIGN.html#runtime-detection","title":"Runtime detection","text":"<p><code>piku</code> follows a very simple set of rules to determine what kind of runtime is required:</p> <ol> <li>If there's a <code>requirements.txt</code> file at the top level, then the app is assumed to require Python.</li> <li>TODO: Go</li> <li>TODO: Node</li> <li>TODO: Java</li> <li>For all the rest, a <code>Procfile</code> is required to determine application entry points. </li> </ol>"},{"location":"DESIGN.html#application-isolation","title":"Application isolation","text":"<p>Application isolation can be tackled at several levels, the most relevant of which being:</p> <ul> <li>OS/process isolation</li> <li>Runtime/library isolation</li> </ul> <p>For 1.0, all applications run under the same <code>uid</code>, under separate branches of the same filesystem, and without any resource limiting.</p> <p>Ways to improve upon that (short of full containerisation) typically entail the use of a <code>chroot</code> jail environment (which is available under most POSIX systems in one form or another) or Linux kernel namespaces - both of which are supported by uWSGI (which can also handle resource limiting to a degree).</p> <p>As to runtime isolation, <code>piku</code> only provides <code>virtualenv</code> support until 1.0. Python apps can run under Python 2 or 3 depending on the setting of <code>PYTHON_VERSION</code>, but will always use pre-installed interpreters (Go, Node and Java support will share these limitations in each major version).</p>"},{"location":"DESIGN.html#internals","title":"Internals","text":"<p><code>piku</code> uses two <code>git</code> repositories for each app: a bare repository for client push, and a clone for deployment (which is efficient in terms of storage since <code>git</code> tries to use hardlinks on local clones whenever possible).</p> <p>This separation makes it easier to cope with long/large deployments and restore apps to a pristine condition, since the app will only go live after the deployment clone is reset (via <code>git checkout -f</code>).</p>"},{"location":"DESIGN.html#components","title":"Components","text":"<p>This diagram (available as a <code>dot</code> file in the <code>img</code> folder) outlines how its components interact:</p> <p></p>"},{"location":"ENV.html","title":"Configuring Piku via ENV","text":"<p>You can configure deployment settings by placing special variables in an <code>ENV</code> file deployed with your app.</p>"},{"location":"ENV.html#runtime-settings","title":"Runtime Settings","text":"<ul> <li><code>PIKU_AUTO_RESTART</code> (boolean, defaults to <code>true</code>): Piku will restart all workers every time the app is deployed. You can set it to <code>0</code>/<code>false</code> if you prefer to deploy first and then restart your workers separately.</li> </ul>"},{"location":"ENV.html#python","title":"Python","text":"<ul> <li><code>PYTHON_VERSION</code> (int): Forces Python 3</li> </ul>"},{"location":"ENV.html#node","title":"Node","text":"<ul> <li><code>NODE_VERSION</code>: installs a particular version of node for your app if <code>nodeenv</code> is found on the path. Optional; if not specified, the system-wide node  package is used.</li> </ul> <p>NOTE: you will need to stop and re-deploy the app to change the <code>node</code> version in a running app.</p>"},{"location":"ENV.html#network-settings","title":"Network Settings","text":"<ul> <li><code>BIND_ADDRESS</code>: IP address to which your app will bind (typically <code>127.0.0.1</code>)</li> <li><code>PORT</code>: TCP port for your app to listen in (if deploying your own web listener).</li> <li><code>DISABLE_IPV6</code> (boolean): if set to <code>true</code>, it will remove IPv6-specific items from the <code>nginx</code> config, which will accept only IPv4 connections</li> </ul>"},{"location":"ENV.html#uwsgi-settings","title":"uWSGI Settings","text":"<ul> <li><code>UWSGI_MAX_REQUESTS</code> (integer): set the <code>max-requests</code> option to determine how many requests a worker will receive before it's recycled.</li> <li><code>UWSGI_LISTEN</code> (integer): set the <code>listen</code> queue size.</li> <li><code>UWSGI_PROCESSES</code> (integer): set the <code>processes</code> count.</li> <li><code>UWSGI_ENABLE_THREADS</code> (boolean): set the <code>enable-threads</code> option.</li> <li><code>UWSGI_LOG_MAXSIZE</code> (integer): set the <code>log-maxsize</code>.</li> <li><code>UWSGI_LOG_X_FORWARDED_FOR</code> (boolean): set the <code>log-x-forwarded-for</code> option.</li> <li><code>UWSGI_GEVENT</code>: enable the Python 2 <code>gevent</code> plugin</li> <li><code>UWSGI_ASYNCIO</code> (integer): enable the Python 2/3 <code>asyncio</code> plugin and set the number of tasks</li> <li><code>UWSGI_INCLUDE_FILE</code>: a uwsgi config file in the app's dir to include - useful for including custom uwsgi directives.</li> <li><code>UWSGI_IDLE</code> (integer): set the <code>cheap</code>, <code>idle</code> and <code>die-on-idle</code> options to have workers spawned on demand and killed after n seconds of inactivity. </li> </ul> <p>NOTE: <code>UWSGI_IDLE</code> applies to all the workers, so if you have <code>UWSGI_PROCESSES</code> set to 4, they will all be killed simultaneously. Support for progressive scaling of workers via <code>cheaper</code> and similar uWSGI configurations will be added in the future. </p>"},{"location":"ENV.html#nginx-settings","title":"<code>nginx</code> Settings","text":"<ul> <li><code>NGINX_SERVER_NAME</code>: set the virtual host name associated with your app</li> <li><code>NGINX_STATIC_PATHS</code> (string, comma separated list): set an array of <code>/url:path</code> values that will be served directly by <code>nginx</code></li> <li><code>NGINX_CLOUDFLARE_ACL</code> (boolean, defaults to <code>false</code>): activate an ACL allowing access only from Cloudflare IPs</li> <li><code>NGINX_HTTPS_ONLY</code> (boolean, defaults to <code>false</code>): tell <code>nginx</code> to auto-redirect non-SSL traffic to SSL site. </li> </ul> <p>NOTE: if used with Cloudflare, <code>NGINX_HTTPS_ONLY</code> will cause an infinite redirect loop - keep it set to <code>false</code>, use <code>NGINX_CLOUDFLARE_ACL</code> instead and add a Cloudflare Page Rule to \"Always Use HTTPS\" for your server (use <code>domain.name/*</code> to match all URLs). </p>"},{"location":"ENV.html#nginx-caching","title":"<code>nginx</code> Caching","text":"<p>When <code>NGINX_CACHE_PREFIXES</code> is set, <code>nginx</code> will cache requests for those URL prefixes to the running application (<code>uwsgi</code>-like or <code>web</code> workers) and reply on its own for <code>NGINX_CACHE_TIME</code> to the outside. This is meant to be used for compute-intensive operations like resizing images or providing large chunks of data that change infrequently (like a sitemap). </p> <p>The behavior of the cache can be controlled with the following variables:</p> <ul> <li><code>NGINX_CACHE_PREFIXES</code> (string, comma separated list): set an array of <code>/url</code> values that will be cached by <code>nginx</code></li> <li><code>NGINX_CACHE_SIZE</code> (integer, defaults to 1): set the maximum size of the <code>nginx</code> cache, in GB</li> <li><code>NGINX_CACHE_TIME</code> (integer, defaults to 3600): set the amount of time (in seconds) that valid backend replies (<code>200 304</code>) will be cached.</li> <li><code>NGINX_CACHE_REDIRECTS</code> (integer, defaults to 3600): set the amount of time (in seconds) that backend redirects (<code>301 307</code>) will be cached.</li> <li><code>NGINX_CACHE_ANY</code> (integer, defaults to 3600): set the amount of time (in seconds) that any other replies (other than errors) will be cached.</li> <li><code>NGINX_CACHE_CONTROL</code> (integer, defaults to 3600): set the amount of time (in seconds) for cache control headers (<code>Cache-Control \"public, max-age=3600\"</code>)</li> <li><code>NGINX_CACHE_EXPIRY</code> (integer, defaults to 86400): set the amount of time (in seconds) that cache entries will be kept on disk.</li> <li><code>NGINX_CACHE_PATH</code> (string, detaults to <code>~piku/.piku/&lt;appname&gt;/cache</code>): location for the <code>nginx</code> cache data.</li> </ul> <p>NOTE: <code>NGINX_CACHE_PATH</code> will be completely managed by <code>nginx</code> and cannot be removed by Piku when the application is destroyed. This is because <code>nginx</code> sets the ownership for the cache to be exclusive to itself, and the <code>piku</code> user cannot remove that file tree. So you will either need to clean it up manually after destroying the app or store it in a temporary filesystem (or set the <code>piku</code> user to the same UID as <code>www-data</code>, which is not recommended).</p> <p>Right now, there is no provision for cache revalidation (i.e., <code>nginx</code> asking your backend if the cache entries are still valid), since that requires active application logic that varies depending on the runtime--<code>nginx</code> will only ask your backend for new content when <code>NGINX_CACHE_TIME</code> elapses. If you require that kind of behavior, that is still possible via <code>NGINX_INCLUDE_FILE</code>.</p> <p>Also, keep in mind that using <code>nginx</code> caching with a <code>static</code> website worker will not work (and there's no point to it either).</p>"},{"location":"ENV.html#nginx-overrides","title":"<code>nginx</code> Overrides","text":"<ul> <li><code>NGINX_INCLUDE_FILE</code>: a file in the app's dir to include in nginx config <code>server</code> section - useful for including custom <code>nginx</code> directives.</li> <li><code>NGINX_ALLOW_GIT_FOLDERS</code>: (boolean) allow access to <code>.git</code> folders (default: false, blocked)</li> </ul>"},{"location":"ENV.html#acme-settings","title":"Acme Settings","text":"<ul> <li><code>ACME_ROOT_CA</code>: set the certificate authority that Acme should use to generate public ssl certificates (string, default: <code>letsencrypt.org</code>)</li> </ul>"},{"location":"FAQ.html","title":"FAQ","text":"<p>Q: Why <code>piku</code>?</p> <p>A: Partly because it's supposed to run on a Pi, because it's Japanese onomatopeia for 'twitch' or 'jolt', and because I know the name will annoy some of my friends.</p> <p>Q: Why Python/why not Go?</p> <p>A: I actually thought about doing this in Go right off the bat, but click is so cool and I needed to have uWSGI running anyway, so I caved in. But I'm very likely to take something like suture and port this across, doing away with uWSGI altogether.</p> <p>Go also (at the time) did not have a way to vendor dependencies that I was comfortable with, and that is also why Go support fell behind. Hopefully that will change soon.</p> <p>Q: Does it run under Python 3?</p> <p>A: Right now, it only runs on Python 3, even though it can deploy apps written in both major versions. It began its development using 2.7 and using<code>click</code> for abstracting the simpler stuff, and I eventually switched over to 3.5 once it was supported in Debian Stretch and Raspbian since I wanted to make installing it on the Raspberry Pi as simple as possible.</p> <p>Q: Why not just use <code>dokku</code>?</p> <p>A: I used <code>dokku</code> daily for most of my personal stuff for a good while. But it relied on a number of <code>x64</code> containers that needed to be completely rebuilt for ARM, and when I decided I needed something like this (March 2016) that was barely possible - <code>docker</code> itself was not fully baked for ARM yet, and people were at the time trying to get <code>herokuish</code> and <code>buildstep</code> to build on ARM.</p>"},{"location":"INSTALL-centos-9.html","title":"Installation on CentOS 9","text":"<p>This is a standalone, distribution-specific version of <code>INSTALL.md</code>. You do not need to read or follow the original file, but can refer to it for generic steps like setting up SSH keys (which are assumed to be common knowledge here)</p> <p>All steps done as root (or add sudo if you prefer).</p>"},{"location":"INSTALL-centos-9.html#dependencies","title":"Dependencies","text":"<p>Before installing <code>piku</code>, you need to install the following packages:</p> <pre><code>dnf in -y ansible-core ansible-collection-ansible-posix ansible-collection-ansible-utils nginx nodejs npm openssl postgresql postgresql-server postgresql-contrib python3 python3-pip uwsgi uwsgi-logger-file uwsgi-logger-systemd\npip install click\n</code></pre>"},{"location":"INSTALL-centos-9.html#set-up-the-piku-user","title":"Set up the <code>piku</code> user","text":"<pre><code>adduser --groups nginx piku\n# copy &amp; setup piku.py\nsu - piku -c \"wget https://raw.githubusercontent.com/piku/piku/master/piku.py &amp;&amp; python3 ~/piku.py setup\"\n</code></pre>"},{"location":"INSTALL-centos-9.html#set-up-ssh-access","title":"Set up SSH access","text":"<p>See INSTALL.md</p>"},{"location":"INSTALL-centos-9.html#uwsgi-configuration","title":"uWSGI Configuration","text":"<p>FYI The uWSGI Emperor \u2013 multi-app deployment</p> <pre><code>mv /home/piku/.piku/uwsgi/uwsgi.ini /etc/uwsgi.d/piku.ini # linking alone increases the host attack service if one can get inside the piku user or one of its apps, so moving is safer\nchown piku:piku /etc/uwsgi.d/piku.ini # In Tyrant mode (set by default in /etc/uwsgi.ini) the Emperor will run the vassal using the UID/GID of the vassal configuration file\nsystemctl restart uwsgi\njournalctl -feu uwsgi # see logs\n</code></pre>"},{"location":"INSTALL-centos-9.html#nginx-configuration","title":"<code>nginx</code> Configuration","text":"<p>FYI Setting up and configuring NGINX</p> <pre><code>echo \"include /home/piku/.piku/nginx/*.conf;\" &gt; /etc/nginx/conf.d/piku.conf\nsystemctl restart nginx\njournalctl -feu nginx # see logs\n</code></pre>"},{"location":"INSTALL-centos-9.html#set-up-systemdpath-to-reload-nginx-upon-config-changes","title":"Set up systemd.path to reload nginx upon config changes","text":"<pre><code># Set up systemd.path to reload nginx upon config changes\nsu -\ngit clone https://github.com/piku/piku.git # need a copy of some files\ncp -v piku/piku-nginx.{path,service} /etc/systemd/system/\nsystemctl enable piku-nginx.{path,service}\nsystemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `active: active (waiting)`\n</code></pre>"},{"location":"INSTALL-centos-9.html#notes","title":"Notes","text":""},{"location":"INSTALL-other.html","title":"Installation on other platforms","text":"<p>This is a standalone, distribution-specific version of <code>INSTALL.md</code>. You do not need to read or follow the original file, but can refer to it for generic steps like setting up SSH keys (which are assumed to be common knowledge here)</p>"},{"location":"INSTALL-other.html#dependencies","title":"Dependencies","text":"<p>Before running <code>piku</code> for the first time, you need to install the following Python packages at the system level:</p>"},{"location":"INSTALL-other.html#raspbian-jessie-debian-8-ubuntu-1604","title":"Raspbian Jessie, Debian 8, Ubuntu 16.04","text":"<pre><code>sudo apt-get install git python3-virtualenv python3-pip\nsudo pip3 install -U click\n</code></pre>"},{"location":"INSTALL-other.html#raspbian-wheezy","title":"Raspbian Wheezy","text":"<pre><code>sudo apt-get install git python3\nsudo easy_install3 -U pip3\nsudo pip3 install -U click virtualenv\n</code></pre> <p>These may or may not be installed already (<code>click</code> usually isn't). For Raspbian Wheezy this is the preferred approach, since current <code>apt</code> packages are fairly outdated.</p>"},{"location":"INSTALL-other.html#set-up-the-piku-user-set-up-ssh-access","title":"Set up the <code>piku</code> user, Set up SSH access","text":"<p>See INSTALL.md</p>"},{"location":"INSTALL-other.html#uwsgi-installation-debian-linux-variants-any-architecture","title":"uWSGI Installation (Debian Linux variants, any architecture)","text":"<p>uWSGI can be installed in a variety of fashions. These instructions cover both pre-packaged and source installs depending on your system.</p>"},{"location":"INSTALL-other.html#raspbian-jessie-debian-8","title":"Raspbian Jessie, Debian 8","text":"<p>Warning</p> <p>These OS releases are no longer supported and these instructions are kept for reference purposes only.</p> <p>In Raspbian Jessie, Debian 8 and other <code>systemd</code> distributions where uWSGI is already available pre-compiled (but split into a number of plugins), do the following:</p> <p><pre><code># At the time of this writing, this installs uwsgi 2.0.7 on Raspbian Jessie.\n# You can also install uwsgi-plugins-all if you want to get runtime support for other languages\nsudo apt-get install uwsgi uwsgi-plugin-python3\n# refer to our executable using a link, in case there are more versions installed\nsudo ln -s `which uwsgi` /usr/local/bin/uwsgi-piku\n# disable the standard uwsgi startup script\nsudo systemctl disable uwsgi\n\n# add our own startup script\nsudo cp /tmp/uwsgi-piku.service /etc/systemd/system/\nsudo systemctl enable uwsgi-piku\nsudo systemctl start uwsgi-piku\n\n# check it's running\nsudo systemctl status uwsgi-piku.service\n</code></pre> Important Note: Make sure you run <code>piku.py setup</code> as outlined above before starting the service.</p> <p>Also, please note that <code>uwsgi-piku.service</code>, as provided, creates a <code>/run/uwsgi-piku</code> directory for it to place socket files and sundry. This is not actually used at the moment, since the <code>uwsgi</code> socket file is placed inside the <code>piku</code> user directory for consistency across OS distributions. This will be cleaned up in a later release.</p>"},{"location":"INSTALL-other.html#raspbian-wheezy_1","title":"Raspbian Wheezy","text":"<p>Warning</p> <p>This OS release is no longer supported and these instructions are kept for reference purposes only.</p> <p>Since Raspbian Wheezy is a fairly old distribution by now, its <code>uwsgi-*</code> packages are completely outdated (and depend on Python 2.6), so we have to compile and install our own version, as well as using an old-style <code>init</code> script to have it start automatically upon boot.</p> <p><pre><code>sudo apt-get install build-essential python-dev libpcre3-dev\n# At the time of this writing, this installs 2.0.12\nsudo pip install uwsgi\n# refer to our executable using a link, in case there are more versions installed\nsudo ln -s `which uwsgi` /usr/local/bin/uwsgi-piku\n\n# set up our init script\nsudo cp /tmp/uwsgi-piku.dist /etc/init.d/uwsgi-piku\nsudo chmod +x /etc/init.d/uwsgi-piku\nsudo update-rc.d uwsgi-piku defaults\nsudo service uwsgi-piku start\n</code></pre> Important Note: Make sure you run <code>python3 piku.py setup</code> as outlined above before starting the service.</p>"},{"location":"INSTALL-other.html#ubuntu-1404-lts","title":"Ubuntu 14.04 LTS","text":"<p>Warning</p> <p>This OS release is no longer supported and these instructions are kept for reference purposes only.</p> <p>This is a mix of both the above, and should change soon when we get 16.04. If you have trouble, install uWSGI via <code>pip</code> instead.</p> <pre><code># At the time of this writing, this installs uwsgi 1.9.17 on Ubuntu 14.04 LTS.\n# You can also install uwsgi-plugins-all if you want to get runtime support for other languages\nsudo apt-get install uwsgi uwsgi-plugin-python3\n# refer to our executable using a link, in case there are more versions installed\nsudo ln -s `which uwsgi` /usr/local/bin/uwsgi-piku\n\n# set up our init script\nsudo cp /tmp/uwsgi-piku.dist /etc/init.d/uwsgi-piku\nsudo chmod +x /etc/init.d/uwsgi-piku\nsudo update-rc.d uwsgi-piku defaults\nsudo service uwsgi-piku start\n</code></pre>"},{"location":"INSTALL-other.html#nginx-installation-raspbian-8-ubuntu-1604","title":"nginx Installation (Raspbian 8, Ubuntu 16.04)","text":"<p>Warning</p> <p>These OS releases are no longer supported and these instructions are kept for reference purposes only.</p> <p>PLEASE NOTE: There is a bug in <code>nginx</code> 1.6.2 under Raspbian 8 that causes it to try to allocate around a gigabyte of RAM when using SSL with SPDY. I seriously recommend using Ubuntu instead, if you can, or disabling SSL altogether.</p> <pre><code>sudo apt-get install nginx\n# Set up nginx to pick up our config files\nsudo cp /tmp/nginx.default.dist /etc/nginx/sites-available/default\n# Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `Active: active (waiting)`\n# Restart NGINX\nsudo systemctl restart nginx\n</code></pre>"},{"location":"INSTALL-other.html#java-8-installation-all-debian-linux-variants-on-raspberry-pi","title":"Java 8 Installation (All Debian Linux variants, on Raspberry Pi)","text":"<p>Warning</p> <p>OpenJDK 8 is no longer shipping with most distributions and these instructions are kept for reference purposes only.</p> <p>To be able to deploy Java apps, we're going to need to install Java (and, since we're going to be doing so on ARM, it's best to use Oracle's runtime). To do that, we're going to use the <code>webupd8team</code> PPA, which has a (cross-platform) Java installer.</p> <p>First, get rid of OpenJDK and import the PPA key:</p> <pre><code>sudo apt-get remove openjdk*\nsudo apt-key adv --recv-key --keyserver keyserver.ubuntu.com EEA14886\n</code></pre>"},{"location":"INSTALL-other.html#raspbian-jessie","title":"Raspbian Jessie","text":"<p>Warning</p> <p>This OS release is no longer supported and these instructions are kept for reference purposes only.</p> <p>For Jessie, we're going to use the <code>trusty</code> version of the installer:</p> <pre><code>sudo tee /etc/apt/sources.list.d/webupd8team.list\ndeb http://ppa.launchpad.net/webupd8team/java/ubuntu trusty main \ndeb-src http://ppa.launchpad.net/webupd8team/java/ubuntu trusty main\n^D\n</code></pre>"},{"location":"INSTALL-other.html#ubuntu-1604-for-arm","title":"Ubuntu 16.04 for ARM","text":"<p>Warning</p> <p>This OS release is no longer supported and these instructions are kept for reference purposes only.</p> <p>For Xenial, we're going to use its own version:</p> <pre><code>sudo tee /etc/apt/sources.list.d/webupd8team.list\ndeb http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main \ndeb-src http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main\n^D\n</code></pre> <p>Now perform the actual install:</p> <pre><code>sudo apt-get update\nsudo apt-get install oracle-java8-installer oracle-java8-set-default\n</code></pre>"},{"location":"INSTALL-other.html#go-installation-all-debian-linux-variants-on-raspberry-pi","title":"Go Installation (All Debian Linux variants, on Raspberry Pi)","text":"<p>This is EXPERIMENTAL and may not work at all.</p>"},{"location":"INSTALL-other.html#raspbian-wheezyjessie","title":"Raspbian Wheezy/Jessie","text":"<p>Warning</p> <p>Wheezy and Jessie are no longer supported and these instructions are kept for reference purposes only.</p> <p>Since Raspbian's Go compiler is version 1.0.2, we need something more up-to-date.</p> <ol> <li>Get an ARM 6 binary tarball</li> <li>Unpack it under the <code>piku</code> user like such:</li> </ol> <pre><code>sudo su - piku\ntar -zxvf /tmp/go1.5.3.linux-arm.tar.gz\n# remove unnecessary files\nrm -rf go/api go/blog go/doc go/misc go/test\n</code></pre> <ol> <li>Give it a temporary <code>GOPATH</code> and install <code>godep</code>:</li> </ol> <pre><code>sudo su - piku\nGOROOT=$HOME/go GOPATH=$HOME/gopath PATH=$PATH:$HOME/go/bin go get github.com/tools/godep\n# temporary workaround until this is fixed in godep or Go 1.7(?)\nGOROOT=$HOME/go GOPATH=$HOME/gopath PATH=$PATH:$HOME/go/bin go get golang.org/x/sys/unix\n</code></pre> <p>TODO: complete this.</p>"},{"location":"INSTALL-raspbian-9.4-stretch-10-buster.html","title":"Installation on Raspbian Stretch or Buster","text":"<p>This is a standalone, distribution-specific version of <code>INSTALL.md</code>. You do not need to read or follow the original file, but can refer to it for generic steps like setting up SSH keys (which are assumed to be common knowledge here)</p> <p><code>piku</code> setup is simplified in modern Debian versions, since it can take advantage of some packaging improvements in uWSGI and does not require a custom <code>systemd</code> service. However, Stretch still ships with Python 3.5, which means it's not an ideal environment for new deployments on both Intel and ARM devices (Buster, in turn, ships with Python 3.7).</p>"},{"location":"INSTALL-raspbian-9.4-stretch-10-buster.html#setting-up-your-raspberry-pi","title":"Setting up your Raspberry Pi","text":"<p>Download and install Raspbian onto an SD card.</p> <p>After you install it is recommended that you do the following to update your installation to the latest available software.</p> <pre><code># update apt-get\nsudo apt-get update\n\n# upgrade all software\nsudo apt-get upgrade\n</code></pre> <p>Configure your installation.  It is recommended that <code>Change Password</code> from the default and setup <code>Locale Options</code> (Locale and Timezone) and <code>EXPAND FILESYSTEM</code>.  You will also want to <code>Enable SSH</code>. <pre><code># configure your installation\nsudo raspi-config\n</code></pre></p> <p>At this point it is a good idea to <code>sudo shutdown -h now</code> and make a backup image of the card.</p>"},{"location":"INSTALL-raspbian-9.4-stretch-10-buster.html#dependencies","title":"Dependencies","text":"<p>Before installing <code>piku</code>, you need to install the following packages:</p> <pre><code>sudo apt-get install -y build-essential certbot git \\\n    libjpeg-dev libxml2-dev libxslt1-dev zlib1g-dev nginx \\\n    python-certbot-nginx python-dev python-pip python-virtualenv \\\n    python3-dev python3-pip python3-click python3-virtualenv \\\n    uwsgi uwsgi-plugin-asyncio-python3 uwsgi-plugin-gevent-python \\\n    uwsgi-plugin-python uwsgi-plugin-python3 uwsgi-plugin-tornado-python \\\n    uwsgi-plugin-lua5.1 uwsgi-plugin-lua5.2 uwsgi-plugin-luajit\n</code></pre>"},{"location":"INSTALL-raspbian-9.4-stretch-10-buster.html#set-up-the-piku-user-set-up-ssh-access","title":"Set up the <code>piku</code> user, Set up SSH access","text":"<p>See INSTALL.md</p>"},{"location":"INSTALL-raspbian-9.4-stretch-10-buster.html#uwsgi-configuration","title":"uWSGI Configuration","text":"<p>uWSGI in Stretch and Buster requires very little configuration, since it is already properly packaged. All you need to do is create a symlink to the <code>piku</code> configuration file in <code>/etc/uwsgi/apps-enabled</code>:</p> <pre><code>sudo ln /home/$PAAS_USERNAME/.piku/uwsgi/uwsgi.ini /etc/uwsgi/apps-enabled/piku.ini\nsudo systemctl restart uwsgi\n</code></pre>"},{"location":"INSTALL-raspbian-9.4-stretch-10-buster.html#nginx-configuration","title":"<code>nginx</code> Configuration","text":"<p><code>piku</code> requires you to edit <code>/etc/nginx/sites-available/default</code> to the following, so it can inject new site configurations into <code>nginx</code>:</p> <pre><code>server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    root /var/www/html;\n    index index.html index.htm;\n    server_name _;\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n# replace `PAAS_USERNAME` with the username you created.\ninclude /home/PAAS_USERNAME/.piku/nginx/*.conf;\n</code></pre>"},{"location":"INSTALL-raspbian-9.4-stretch-10-buster.html#set-up-systemdpath-to-reload-nginx-upon-config-changes","title":"Set up systemd.path to reload nginx upon config changes","text":"<pre><code># Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `Active: active (waiting)`\n# Restart NGINX\nsudo systemctl restart nginx\n</code></pre>"},{"location":"INSTALL-raspbian-9.4-stretch-10-buster.html#notes","title":"Notes","text":"<p>This file was last updated on June 2019</p>"},{"location":"INSTALL-ubuntu-18.04-bionic.html","title":"Installation on Ubuntu 18.04 LTS (Bionic)","text":"<p>This is a standalone, distribution-specific version of <code>INSTALL.md</code>. You do not need to read or follow the original file, but can refer to it for generic steps like setting up SSH keys (which are assumed to be common knowledge here)</p> <p><code>piku</code> setup is simplified in Bionic, since it can take advantage of some packaging improvements in uWSGI and does not require a custom <code>systemd</code> service. Since Bionic also ships with Python 3.6, this is an ideal environment for new deployments on both Intel and ARM devices.</p>"},{"location":"INSTALL-ubuntu-18.04-bionic.html#dependencies","title":"Dependencies","text":"<p>Before installing <code>piku</code>, you need to install the following packages:</p> <pre><code>sudo apt-get update\nsudo apt-get install -y build-essential certbot git \\\n    libjpeg-dev libxml2-dev libxslt1-dev zlib1g-dev nginx \\\n    python-certbot-nginx python-dev python-pip python-virtualenv \\\n    python3-dev python3-pip python3-click python3-virtualenv \\\n    uwsgi uwsgi-plugin-asyncio-python3 uwsgi-plugin-gevent-python \\\n    uwsgi-plugin-python uwsgi-plugin-python3 uwsgi-plugin-tornado-python\n</code></pre>"},{"location":"INSTALL-ubuntu-18.04-bionic.html#set-up-the-piku-user-set-up-ssh-access","title":"Set up the <code>piku</code> user, Set up SSH access","text":"<p>See INSTALL.md</p>"},{"location":"INSTALL-ubuntu-18.04-bionic.html#uwsgi-configuration","title":"uWSGI Configuration","text":"<p>uWSGI requires very little configuration, since it is already properly packaged. All you need to do is place a link to the <code>piku</code> configuration file in <code>/etc/uwsgi/apps-enabled</code>:</p> <pre><code>sudo ln /home/$PAAS_USERNAME/.piku/uwsgi/uwsgi.ini /etc/uwsgi/apps-enabled/piku.ini\nsudo systemctl restart uwsgi\n</code></pre>"},{"location":"INSTALL-ubuntu-18.04-bionic.html#nginx-configuration","title":"<code>nginx</code> Configuration","text":"<p><code>piku</code> requires you to edit <code>/etc/nginx/sites-available/default</code> to the following, so it can inject new site configurations into <code>nginx</code>:</p> <pre><code>server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    root /var/www/html;\n    index index.html index.htm;\n    server_name _;\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n# replace `PAAS_USERNAME` with the username you created.\ninclude /home/PAAS_USERNAME/.piku/nginx/*.conf;\n</code></pre>"},{"location":"INSTALL-ubuntu-18.04-bionic.html#set-up-systemdpath-to-reload-nginx-upon-config-changes","title":"Set up systemd.path to reload nginx upon config changes","text":"<pre><code># Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `Active: active (waiting)`\n# Restart NGINX\nsudo systemctl restart nginx\n</code></pre>"},{"location":"INSTALL-ubuntu-18.04-bionic.html#notes","title":"Notes","text":"<p>This file was last updated on November 2018</p>"},{"location":"INSTALL-ubuntu-22.04-jammy.html","title":"Installation on Ubuntu 22.04 LTS (Jammy)","text":"<p>This is a standalone, distribution-specific version of <code>INSTALL.md</code>. You do not need to read or follow the original file, but can refer to it for generic steps like setting up SSH keys (which are assumed to be common knowledge here)</p> <p><code>piku</code> setup is simplified in Jammy, since it can take advantage of some packaging improvements in uWSGI and does not require a custom <code>systemd</code> service. Since Jammy also ships with Python 3.10, this is an ideal environment for new deployments on both Intel and ARM devices.</p>"},{"location":"INSTALL-ubuntu-22.04-jammy.html#dependencies","title":"Dependencies","text":"<p>Before installing <code>piku</code>, you need to install the following packages:</p> <pre><code>sudo apt-get update\nsudo apt-get install -y build-essential certbot git \\\n    libjpeg-dev libxml2-dev libxslt1-dev zlib1g-dev nginx \\\n    python3-certbot-nginx \\\n    python3-dev python3-pip python3-click python3-virtualenv \\\n    uwsgi uwsgi-plugin-asyncio-python3 uwsgi-plugin-gevent-python3 \\\n    uwsgi-plugin-python3 uwsgi-plugin-tornado-python3\n</code></pre>"},{"location":"INSTALL-ubuntu-22.04-jammy.html#set-up-the-piku-user-set-up-ssh-access","title":"Set up the <code>piku</code> user, Set up SSH access","text":"<p>See INSTALL.md</p>"},{"location":"INSTALL-ubuntu-22.04-jammy.html#uwsgi-configuration","title":"uWSGI Configuration","text":"<p>uWSGI requires very little configuration, since it is already properly packaged. All you need to do is place a link to the <code>piku</code> configuration file in <code>/etc/uwsgi/apps-enabled</code>:</p> <pre><code>sudo ln /home/$PAAS_USERNAME/.piku/uwsgi/uwsgi.ini /etc/uwsgi/apps-enabled/piku.ini\nsudo systemctl restart uwsgi\n</code></pre>"},{"location":"INSTALL-ubuntu-22.04-jammy.html#nginx-configuration","title":"<code>nginx</code> Configuration","text":"<p><code>piku</code> requires you to edit <code>/etc/nginx/sites-available/default</code> to the following, so it can inject new site configurations into <code>nginx</code>:</p> <pre><code>server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    root /var/www/html;\n    index index.html index.htm;\n    server_name _;\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n# replace `PAAS_USERNAME` with the username you created.\ninclude /home/PAAS_USERNAME/.piku/nginx/*.conf;\n</code></pre>"},{"location":"INSTALL-ubuntu-22.04-jammy.html#set-up-systemdpath-to-reload-nginx-upon-config-changes","title":"Set up systemd.path to reload nginx upon config changes","text":"<pre><code># Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `Active: active (waiting)`\n# Restart NGINX\nsudo systemctl restart nginx\n</code></pre>"},{"location":"INSTALL-ubuntu-22.04-jammy.html#notes","title":"Notes","text":"<p>This file was last updated on November 2018</p>"},{"location":"INSTALL.html","title":"Installation","text":"<p><code>piku</code> requires <code>Python 3</code>, uWSGI, SSH, and a Linux distribution that runs <code>systemd</code>, such as Raspbian Jessie/Debian 8+/Ubuntu/Fedora/CentOS.</p> <p>There are 3 ways to install piku on a server:</p> <ol> <li> <p>Manually: Follow INSTALL-x.md for which ever platform. If you are running <code>piku</code> on specific Linux versions, feel free to contribute your own instructions.</p> </li> <li> <p>Use cloud-init to do it automatically at VPS build time: https://github.com/piku/cloud-init</p> </li> <li> <p>Use piku-bootstrap to do it once your box is already provisioned: https://github.com/piku/piku-bootstrap</p> </li> </ol>"},{"location":"INSTALL.html#generic-steps-referenced-from-install-x","title":"Generic steps (referenced from INSTALL-x)","text":""},{"location":"INSTALL.html#set-up-the-piku-user","title":"Set up the <code>piku</code> user","text":"<p><code>piku</code> requires a separate user account to run. To create a new user with the right group membership (we're using the built-in <code>www-data</code> group because it's generally thought of as a less-privileged group), enter the following command:</p> <pre><code># pick a username\nexport PAAS_USERNAME=piku\n# create it\nsudo adduser --disabled-password --gecos 'PaaS access' --ingroup www-data $PAAS_USERNAME\n# copy &amp; setup piku.py\nsudo su - $PAAS_USERNAME -c \"wget https://raw.githubusercontent.com/piku/piku/master/piku.py &amp;&amp; python3 ~/piku.py setup\"\n</code></pre> <p>The <code>setup</code> output should be something like this:</p> <pre><code>Creating '/home/piku/.piku/apps'.\nCreating '/home/piku/.piku/repos'.\nCreating '/home/piku/.piku/envs'.\nCreating '/home/piku/.piku/uwsgi'.\nCreating '/home/piku/.piku/uwsgi-available'.\nCreating '/home/piku/.piku/uwsgi-enabled'.\nCreating '/home/piku/.piku/logs'.\nSetting '/home/piku/piku.py' as executable.\n</code></pre>"},{"location":"INSTALL.html#set-up-ssh-access","title":"Set up SSH access","text":"<p>If you don't have an SSH public key (or never used one before), you need to create one. The following instructions assume you're running some form of UNIX on your own machine (Windows users should check the documentation for their SSH client, unless you have Cygwin installed).</p> <p>On your own machine, issue the <code>ssh-keygen</code> command and follow the prompts:</p> <pre><code>ssh-keygen \n\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/youruser/.ssh/id_rsa): \nCreated directory '/home/youruser/.ssh'.\nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in /home/youruser/.ssh/id_rsa.\nYour public key has been saved in /home/youruser/.ssh/id_rsa.pub.\nThe key fingerprint is:\n85:29:07:cb:de:ad:be:ef:42:65:00:c8:d2:6b:9e:ff youruser@yourlaptop.lan\nThe key's randomart image is:\n+--[ RSA 2048]----+\n&lt;...&gt;\n+-----------------+\n</code></pre> <p>Copy the resulting <code>id_rsa.pub</code> (or equivalent, just make sure it's the public file) to your <code>piku</code> server and do the following:</p> <pre><code>sudo su - piku\npython3 piku.py setup:ssh /tmp/id_rsa.pub\n\nAdding key '85:29:07:cb:de:ad:be:ef:42:65:00:c8:d2:6b:9e:ff'.\n</code></pre> <p>Now if you look at <code>.ssh/authorized_keys</code>, you should see something like this:</p> <pre><code>sudo su - piku\ncat .ssh/authorized_keys\n\ncommand=\"FINGERPRINT=85:29:07:cb:de:ad:be:ef:42:65:00:c8:d2:6b:9e:ff NAME=default /home/piku/piku.py $SSH_ORIGINAL_COMMAND\",no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDhTYZi/qeJBKgU3naI8FNjQgeMYnMsEtqrOmUc4lJoPNH2qBUTNkzwThGqsBm2HNLPURWMiEifBqF+kRixMud67Co7Zs9ys7pwFXkJB9bbZasd2JCGfVZ4UYXHnvgejSWkLAV/4bObhsbP2vWOmbbm91Cwn+PGJgoiW08yrd45lsDmgv9cUAJS3e8LkgVELvIDg49yM5ArB88oxwMEoUgWU2OniHmH0o1zw5I8WXHRhHOjb8cGsdTYfXEizRKKRTM2Mu6dKRt1GNL0UbWi8iS3uJHGD3AcQ4ApdMl5X0gTixKHponStOrSMy19/ltuIy8Sjr7KKPxz07ikMYr7Vpcp youruser@yourlaptop.lan\n</code></pre> <p>This line is what enables you to SSH (and perform <code>git</code> over SSH operations) to the <code>piku</code> user without a password, verifying your identity via your public key, restricting what can be done remotely and passing on to <code>piku</code> itself the commands you'll be issuing.</p>"},{"location":"INSTALL.html#test","title":"Test","text":"<p>From your machine, do:</p> <pre><code>ssh piku@pi.lan\n\nUsage: piku.py [OPTIONS] COMMAND [ARGS]...\n\n  The smallest PaaS you've ever seen\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  apps              List applications\n  config            Show application configuration\n  config:get        Retrieve a configuration setting\n  config:live       Show live configuration settings\n  config:set        Set a configuration setting\n  deploy            Deploy an application\n  destroy           Destroy an application\n  disable           Disable an application\n  enable            Enable an application\n  logs              Tail an application log\n  ps                Show application worker count\n  ps:scale          Show application configuration\n  restart           Restart an application\n  setup             Initialize paths\n  setup:ssh         Set up a new SSH key\nConnection to pi.lan closed.\n</code></pre>"},{"location":"PLUGINS.html","title":"PLUGINS","text":"<p>Thanks to jsenin, <code>piku</code> currently has experimental support for external plugins via #129. </p> <p>Plugins are inserted into the commands listing and can perform arbitrary actions. At this moment there are no official plugins, but here is an example file that should be placed at <code>~/.piku/plugins/postgres/__init__.py</code> that could contain the commands to manage a Postgres database:</p> <pre><code>import click\n\n@click.group()\ndef postgres():\n    \"\"\"Postgres command plugin\"\"\"\n    pass\n\n@postgres.command(\"postgres:create\")\n@click.argument('name')\n@click.argument('user')\n@click.argument('password')\ndef postgres_create():\n    \"\"\"Postgres create a database\"\"\"\n    pass\n\n@postgres.command(\"postgres:drop\")\n@click.argument('name')\ndef postgres_drop():\n    \"\"\"Postgres drops a database\"\"\"\n    pass\n\n@postgres.command(\"postgres:import\")\n@click.argument('name')\ndef postgres_drop():\n    \"\"\"Postgres import a database\"\"\"\n    pass\n\n@postgres.command(\"postgres:dump\")\n@click.argument('name')\ndef postgres_drop():\n    \"\"\"Postgres dumps a database SQL\"\"\"\n    pass\n\ndef cli_commands():\n    return postgres\n</code></pre>"},{"location":"old/RASPBERRY_PI_QUICKSTART.html","title":"Setting up a Raspberry Pi Piku Server from Scratch","text":""},{"location":"old/RASPBERRY_PI_QUICKSTART.html#disclaimer","title":"DISCLAIMER!","text":""},{"location":"old/RASPBERRY_PI_QUICKSTART.html#these-instructions-are-correct-as-of-april-1st-2016","title":"These instructions are correct as of April 1st 2016","text":"<p>Start by flashing a SD card with the latest Raspbian Jessie Lite image.</p>"},{"location":"old/RASPBERRY_PI_QUICKSTART.html#do-this-in-your-raspberry-pi-as-pi-user","title":"Do this in your Raspberry Pi as 'pi' user","text":"<p>Boot it, launch raspi-config to perform (at least) the following configuration:</p> <pre><code># as 'pi' user\nsudo raspi-config\n</code></pre> <ul> <li>1) expand filesystem </li> <li>2) change default user password</li> <li>3) set up memory split as you wish (for a headless server, 16MB for GPU)</li> </ul> <p>Optionally:</p> <ul> <li>4) set up over-clocking.</li> </ul>"},{"location":"old/RASPBERRY_PI_QUICKSTART.html#secure-your-install","title":"Secure your install","text":"<p>Delete the existing SSH keys and recreate them (why? read this).</p> <pre><code># as 'pi' user\nsudo rm -v /etc/ssh/ssh_host_*\nsudo dpkg-reconfigure openssh-server\nsudo reboot\n</code></pre> <p>This will recreate the server keys. Next, update your system:</p> <pre><code># as 'pi' user\nsudo apt update\nsudo apt upgrade\n</code></pre>"},{"location":"old/RASPBERRY_PI_QUICKSTART.html#install-required-packages","title":"Install required packages","text":"<p>As of April 2016, the shipping versions with Raspbian are recent enough to run <code>piku</code>:</p> <pre><code># as 'pi' user\nsudo apt install -y python-virtualenv python-pip git uwsgi uwsgi-plugin-python nginx\nsudo pip install -U click\nsudo reboot\n</code></pre>"},{"location":"old/RASPBERRY_PI_QUICKSTART.html#meanwhile-go-get-the-goodies-while-raspberry-pi-is-rebooting","title":"Meanwhile, go get the goodies while Raspberry Pi is rebooting","text":"<p>(We assume you know about ssh keys and have one \"at hand\", you'll need to copy it)</p> <p>Clone the piku repo somewhere and copy files to your Raspberry Pi</p> <pre><code># as yourself in your desktop/laptop computer\nscp piku.py uwsgi-piku.service nginx.default.dist pi@your_machine:/tmp\nscp your_public_ssh_key.pub pi@your_machine:/tmp\n</code></pre>"},{"location":"old/RASPBERRY_PI_QUICKSTART.html#back-to-the-pi","title":"Back to the Pi","text":"<p>Prepare uWSGI (part one): <pre><code># as 'pi' user\nsudo ln -s `which uwsgi` /usr/local/bin/uwsgi-piku\nsudo systemctl disable uwsgi\nsudo cp /tmp/uwsgi-piku.service /etc/systemd/system/\nsudo systemctl daemon-reload\nsudo systemctl enable uwsgi-piku\n</code></pre></p> <p>Prepare nginx:</p> <pre><code>sudo apt-get install nginx\n# Set up nginx to pick up our config files\nsudo cp /tmp/nginx.default.dist /etc/nginx/sites-available/default\n# Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `Active: active (waiting)`\n# Restart NGINX\nsudo systemctl restart nginx\n</code></pre> <p>Create 'piku' user and set it up</p> <pre><code># as 'pi' user\nsudo adduser --disabled-password --gecos 'PaaS access' --ingroup www-data piku\nsudo su - piku\n# this is now done as 'piku' user\nmkdir ~/.ssh\nchmod 700 ~/.ssh\ncp /tmp/piku.py ~/piku.py\npython piku.py setup\npython piku.py setup:ssh /tmp/id_rsa.pub\n# return to 'pi' user\nexit\n</code></pre> <p>Prepare uWSGI (part two):</p> <pre><code># as 'pi' user\nsudo systemctl start uwsgi-piku\nsudo systemctl status uwsgi-piku.service\n</code></pre>"},{"location":"old/RASPBERRY_PI_QUICKSTART.html#if-youre-still-here-odds-are-your-pi-is-ready-for-work","title":"If you're still here, odds are your Pi is ready for work","text":"<p>Go back to your machine and try these commands:</p> <pre><code># as yourself in your desktop/laptop computer\nssh piku@your_machine\n\nUsage: piku.py [OPTIONS] COMMAND [ARGS]...\n\n  The smallest PaaS you've ever seen\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  apps              List applications\n  config            Show application configuration\n  config:get        Retrieve a configuration setting\n  config:live       Show live configuration settings\n  config:set        Set a configuration setting\n  deploy            Deploy an application\n  destroy           Destroy an application\n  disable           Disable an application\n  enable            Enable an application\n  logs              Tail an application log\n  ps                Show application worker count\n  ps:scale          Show application configuration\n  restart           Restart an application\n  setup             Initialize paths\n  setup:ssh         Set up a new SSH key\nConnection to your_machine closed.\n</code></pre> <p>If you find any bugs with this quickstart guide, please let Luis Correia know ;)</p>"},{"location":"old/ROADMAP.html","title":"Roadmap","text":"<p>This was the original roadmap, filed here in 2019-11-21 for future reference:</p> <ul> <li>[ ] Prebuilt Raspbian image with everything baked in</li> <li>[ ] <code>chroot</code>/namespace isolation (tentative)</li> <li>[ ] Relay commands to other nodes</li> <li>[ ] Proxy deployments to other nodes (build on one box, deploy to many)</li> <li>[ ] Support Clojure/Java deployments through <code>boot</code> or <code>lein</code></li> <li>[ ] Sample Go app</li> <li>[ ] Support Go deployments (in progress)</li> <li>[ ] nginx SSL optimization/cypher suites, own certificates</li> <li>[ ] Review deployment messages</li> <li>[ ] WIP: Review docs/CLI command documentation (short descriptions done, need <code>help &lt;cmd&gt;</code> and better descriptions)</li> <li>[ ] Lua/WSAPI support</li> <li>[x] Support for Java Apps with maven/gradle (in progress through jwsgi, by @matrixjnr)</li> <li>[x] Django and Wisp examples (by @chr15m)</li> <li>[x] Project logo (by @chr15m)</li> <li>[x] Various release/deployment improvements (by @chr15m)</li> <li>[x] Support Node deployments (by @chr15m)</li> <li>[x] Let's Encrypt support (by @chr15m)</li> <li>[x] Allow setting <code>nginx</code> IP bindings in <code>ENV</code> file (<code>NGINX_IPV4_ADDRESS</code> and <code>NGINX_IPV6_ADDRESS</code>)</li> <li>[x] Cleanups to remove 2.7 syntax internally</li> <li>[x] Change to Python 3 runtime as default, with <code>PYTHON_VERSION = 2</code> as fallback</li> <li>[x] Run in Python 3 only</li> <li>[x] (experimental) REPL in <code>feature/repl</code></li> <li>[x] Python 3 support through <code>PYTHON_VERSION = 3</code></li> <li>[x] static URL mapping to arbitrary paths (hat tip to @carlosefr for <code>nginx</code> tuning)</li> <li>[x] remote CLI (requires <code>ssh -t</code>)</li> <li>[x] saner uWSGI logging</li> <li>[x] <code>gevent</code> activated when <code>UWSGI_GEVENT = &lt;integer&gt;</code></li> <li>[x] enable CloudFlare ACL when <code>NGINX_CLOUDFLARE_ACL = True</code></li> <li>[x] Autodetect SPDY/HTTPv2 support and activate it</li> <li>[x] Basic nginx SSL config with self-signed certificates and UNIX domain socket connection</li> <li>[x] nginx support - creates an nginx config file if <code>NGINX_SERVER_NAME</code> is defined</li> <li>[x] Testing with pre-packaged uWSGI versions on Debian Jessie (yes, it was painful)</li> <li>[x] Support barebones binary deployments</li> <li>[x] Complete installation instructions (see <code>INSTALL.md</code>, which also has a draft of Go installation steps)</li> <li>[x] Installation helper/SSH key setup</li> <li>[x] Worker scaling</li> <li>[x] Remote CLI commands for changing/viewing applied/live settings</li> <li>[x] Remote tailing of all logfiles for a single application</li> <li>[x] HTTP port selection (and per-app environment variables)</li> <li>[x] Sample Python app</li> <li>[X] <code>Procfile</code> support (<code>wsgi</code> and <code>worker</code> processes for now, <code>web</code> processes being tested)</li> <li>[x] Basic CLI commands to manage apps</li> <li>[x] <code>virtualenv</code> isolation</li> <li>[x] Support Python deployments</li> <li>[x] Repo creation upon first push</li> <li>[x] Basic understanding of how <code>dokku</code> works</li> </ul>"},{"location":"old/SCRIPTS.html","title":"Ubuntu 16.04","text":"<p>Full installation sequence on a blank Ubuntu 16.04 machine:</p> <pre><code>sudo apt-get update\nsudo apt-get -y dist-upgrade\nsudo apt-get -y autoremove\nsudo apt-get install -y tmux vim htop fail2ban uwsgi uwsgi-plugin-python uwsgi-plugin-python3 uwsgi-plugin-asyncio-python3 uwsgi-plugin-gevent-python uwsgi-plugin-tornado-python nginx libxml2-dev libxslt1-dev python-dev zlib1g-dev build-essential git python3-virtualenv python3-pip python3-click\nsudo pip3 install -U click pip\nsudo adduser --disabled-password --gecos 'PaaS access' --ingroup www-data piku\n\n# move to /tmp and grab our distribution files\ncd /tmp\nwget https://raw.githubusercontent.com/piku/piku/master/piku.py\nwget https://raw.githubusercontent.com/piku/piku/master/piku-nginx.path\nwget https://raw.githubusercontent.com/piku/piku/master/piku-nginx.service\nwget https://raw.githubusercontent.com/piku/piku/master/nginx.default.dist\nwget https://raw.githubusercontent.com/piku/piku/master/uwsgi-piku.service\n# Set up nginx to pick up our config files\nsudo cp /tmp/nginx.default.dist /etc/nginx/sites-available/default\n# Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Restart NGINX\nsudo systemctl restart nginx\nsudo cp /tmp/uwsgi-piku.service /etc/systemd/system/\n# refer to our executable using a link, in case there are more versions installed\nsudo ln -s `which uwsgi` /usr/local/bin/uwsgi-piku\n# disable the standard uwsgi startup script\nsudo systemctl disable uwsgi\nsudo systemctl enable uwsgi-piku\nsudo su - piku\nmkdir ~/.ssh\nchmod 700 ~/.ssh\n# now copy the piku script to this user account\ncp /tmp/piku.py ~/piku.py\npython3 piku.py setup\n# Now import your SSH key using setup:ssh\n\nsudo systemctl start uwsgi-piku\n</code></pre>"}]}